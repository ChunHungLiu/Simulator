I. TagStoreDBI.h
-------------------

No need for a separate TagStore as Generic Tagstore just deals with value_t, the changes need to be made to value_t which is  a 
part of CacheTagValue defined in CmpCache. 






II. DBIComplex.h
----------------
It will be a map. The keys for the elements will be the DRAM row ids and the values will be bitvectors corresponding to dirty bit 
values of all the blocks that belong to the corresponding DRAM row id. 
It will also have variable corresponding to size and fill number.
To start off, the size of the DBI will be equal to the number of cache lines in the cache ((cache -> _size)/(cache -> 
_blocksize)), so that we don't hav to bother about eviction logic when this data structure is smaller than cache size. 

The constructor will take size as an argument, also info about DRAM row size (_rowSize) and number of banks (_numBanks). Actually 
we just need to know the logical row id, no need for bank index. SO just take the virtual address as input and compute its logical 
row id and set corresponding bit.  

An element wil be accessed by a key (rowId), and will have only bitvector and a valid bit.  

The functions will be :  

1. Setting the dirty bit given the block addresss
   _tags[ctag].dirty = true;
   Replacement : setDirty(_dbi, ctag);			// ctag is of type addr_t, it represents the block address
   What is ctag ? 

2. check if the dirty bit value of a tagentry is set or not ? 
   if(tagentry.value.dirty)
   Replacement : if(isDirty(tagentry.key))   // key is of type addr_t


Changes for dbi need to made wherever there is an addition or deletion of tagentry in the tagstore. 
And also whenever dirty bit is checked or set. 


adding new entries and removing entries is implemented inside the DBI structure. Now if we need to flush or do eviction from the 
DBI, we need to implement this logic in the LLC. Also, with the addition and deletion of entries inside the cache tagstore, we 
need to simultaneously add and rmeove the elements from the DBI. 




III. CmpLLCDBI.h
---------------------

The changes need to be made to TagEntry in this. The dirty bit info for the cache lines need to be accessed from the DBI. 


Addresses generated by the cache are virtual block addresses which don't fit in physical space of the dbi. 


we need to determine the actual indices for the dbi according to the cache indices


We will have to use bank index and row id 



IV. DBI.h
-----------------------------

Just store dirty bit info for all ctags without bothering about size or physical mapping. This won't lead to problems if the DBI 
size is intended to be equal to the number of rows present in DRAM. 





V. Modifications to LLCwAWB (LLC with aggressive writeback)
----------------------------------------------------------------

You have to keep monitoring the DBI for cleaning operations
Whenever there is an eviction, store the logicalRow of the evicted block in a register and a flag to indicate if that row has been 
cleaned or not. Now in ProcessReturn of every request, after we have serviced the return, take a look at cleaning row and flag 
and access the DBI. If there are dirty bits still pending, pick one, generate a clean request and push it into the queue of the 
LLC. At the same time, clear the dirty bit in the DBI. If there are no dirty bits pending, clear the clean row register and reset 
the clean flag. Now again wait for another writeback due to eviction and once you see one, repeat the process. 

The clean requests, when returned, will have to be destroyed by the LLC. 

This mechanism has the disadvantage that even after the writes corresponding to a particular row have been drained, you keep 
generating writebacks for that row. A mechanism has to be devised for allowing to generate writebacks for a row which has opened 
for write and thus clean out the entire row from the DBI. 

Also, at times , when we are cleaning out a particular row, we are missing out opportunities to clean rows of other demand 
accesses that come in between (is it negligible). 




Also, should we have a bitvector for each row in the DBI or a structure which stores the block ids in a growing list format. 
Becomes disadvantageous if there are more than around 16 dirty blocks per row (assuming 128 blocks per row)






If we assume DBI has entries for all the rows of DRAM , then for a 4MB LLC, and a 4GB RAM 
Earlier dirty bit storage required = 64 kB
Newer dirty bit storage required = 64 MB, which is huge
We can afford to store only around 8 rows in 64kB, and that is not guaranteed to have high utilization

